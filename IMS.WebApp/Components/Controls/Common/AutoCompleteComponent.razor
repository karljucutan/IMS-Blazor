<div class="form-group">
    <label for="search">@Label</label>
    <input
        type="text"
        class="form-control"
        @bind-value="UserInput"
        @bind-value:event="oninput" 
        @onkeyup="OnKeyup"/>
</div>

@if (searchResults is not null && searchResults.Any())
{
    <div class="search-result">
        <ul>
            @for (int index = 0; index < searchResults.Count; index++)
            {
                var item = searchResults[index];
                // The @key directive is used to optimize rendering performance by helping Blazor identify elements during updates,
                // similar to how indexing works for databases.
                <li @key="item.Id"
                    class="@(item == currentItem ? "selected" : "")"
                    @onclick="() => HandleSelectItem(item)">
                    @item.Name
                </li>
            }
        </ul>
    </div>
}

@code {
    public class ItemViewModel
    {
        public int Id { get; set; }
        public string Name { get; set; } = string.Empty;
    }

    private string _userInput = string.Empty;
    private List<ItemViewModel>? searchResults = null;
    private ItemViewModel? selectedItem = null;
    private ItemViewModel? currentItem = null;
    private int currentItemIndex = -1;

    [Parameter]
    public string Label { get; set; } = string.Empty;

    // NOTE
    // Func<T, TResult>
    // Purpose: Func<T, TResult> is used to pass a function from the parent component to the child component.The child component can call this function to get some result based on the input.
    // Usage: Suitable for scenarios where the child component needs to delegate some processing to the parent component, like data fetching, complex calculations, etc.
    // Synchronous and Asynchronous: Func<T, TResult> is generally synchronous, but you can use Func<Task<TResult>> or similar for asynchronous operations.
    
    
    // [Parameter]
    // public Func<string, List<ItemViewModel>>? SearchFunction { get; set; }

    // async implementation
    [Parameter]
    public Func<string, Task<List<ItemViewModel>>>? SearchFunction { get; set; }

    [Parameter]
    public EventCallback<ItemViewModel> OnItemSelected { get; set; }

    #region UserInput with Sychronus Call of SearchFunction
    // public string UserInput 
    // { 
    //     get => _userInput;
    //     set 
    //     {
    //         _userInput = value;

    //         if (!string.IsNullOrWhiteSpace(_userInput) && SearchFunction is not null)
    //             searchResults = SearchFunction(_userInput);
    //     } 
    // }
    #endregion

    public string UserInput
    {
        get => _userInput;
        set
        {
            _userInput = value;

            if (!string.IsNullOrWhiteSpace(_userInput) && SearchFunction is not null)
            {
                // Run the search asynchronously
                PerformSearchAsync(_userInput);
            }
        }
    }

    private async Task PerformSearchAsync(string input)
    {
        if (SearchFunction is not null)
        {
            searchResults = await SearchFunction(input);
            // Handle the results
            // For example, you can set a separate property to display the results in the UI
            StateHasChanged(); // Trigger UI update
        }
    }

    private void HandleSelectItem(ItemViewModel item)
    {
        if (item is not null)
        {
            selectedItem = item;
            UserInput = item.Name ?? string.Empty;
            OnItemSelected.InvokeAsync(item);
        }
        ClearHighlighting();
    }

    private void OnKeyup(KeyboardEventArgs keyboardEventArgs)
    {
        if (searchResults is not null &&
            searchResults.Any())
        {
            if (keyboardEventArgs.Code == "ArrowDown" && currentItemIndex < searchResults.Count - 1)
                currentItem = searchResults[++currentItemIndex];

            else if (keyboardEventArgs.Code == "ArrowUp" && currentItemIndex > 0)
                currentItem = searchResults[--currentItemIndex];

            else if (keyboardEventArgs.Code == "Enter" || keyboardEventArgs.Code == "NumpadEnter")
                HandleSelectItem(currentItem);
        }
    }

    private void ClearHighlighting()
    {
        searchResults = null;
        currentItem = null;
        currentItemIndex = -1;
    }
}
